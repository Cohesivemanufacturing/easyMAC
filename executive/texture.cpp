//#include "stdafx.h"
#include "texture.h"
#include "stb_image.h"
#include <iostream>
#include <cassert>

Texture::Texture(const std::string& fileName)
{
	int width, height, numComponents;
	unsigned char* data = stbi_load((fileName).c_str(), &width, &height, &numComponents, 4);

	if (data == NULL)
		std::cerr << "Unable to load texture: " << fileName << std::endl;

	glGenTextures(1, &m_texture);          // m_texture is a handle to the space generated by glGenTexture
	glBindTexture(GL_TEXTURE_2D, m_texture);

	glTexParameteri(GL_TEXTURE_2D, 
					GL_TEXTURE_WRAP_S,     // reading outside the texture image width
					GL_REPEAT);            // if reading outside the texture image width, start from begining
	glTexParameteri(GL_TEXTURE_2D,         // reading outside the texture image height
					GL_TEXTURE_WRAP_T,	   // if reading outside the texture image height, start from begining
					GL_REPEAT);

	glTexParameterf(GL_TEXTURE_2D,         // interpolation of texture (minification, when the texture takes pixed than the texture image resolution)
		            GL_TEXTURE_MIN_FILTER, // linear interpolation
		            GL_LINEAR);
	glTexParameterf(GL_TEXTURE_2D,          // target
					GL_TEXTURE_MAG_FILTER,  // Zero is default level. Allows textures of different res. form the same image. Higher res. textures when the image is closer to the camara.
					GL_LINEAR);             // store pixels in RGBA
	
	glTexImage2D(GL_TEXTURE_2D,             // Zero is default level. Allows textures of different res. form the same image. Higher res. textures when the image is closer to the camara.
				 0,							// store pixels in RGBA
				 GL_RGBA, 
				 width, 
				 height, 
				 0, 
				 GL_RGBA,                   // format of the pixel sent to the GPU
				 GL_UNSIGNED_BYTE,          // how are the pixels sorted
				 data);                     // pointer to all the data of the pixels

	stbi_image_free(data);
}

Texture::~Texture()
{
	glDeleteTextures(1, &m_texture);
}

void Texture::Bind(unsigned int unit)
{
	assert(unit >= 0 && unit <= 31);

	glActiveTexture(GL_TEXTURE0 + unit);     // changes the texture unit that openGL working with 
	glBindTexture(GL_TEXTURE_2D, m_texture); // bind our texture to that unit. all future texture operations form here will be using m_texture
}